From c3fc6da34c3c0059940bb84597ae955953d3636b Mon Sep 17 00:00:00 2001
From: Neil Armstrong <narmstrong@baylibre.com>
Date: Mon, 26 Aug 2019 17:27:26 +0200
Subject: [PATCH 110/155] TEMP: clk: meson: g12a: add suspend-resume hooks

---
 drivers/clk/meson/g12a.c | 145 ++++++++++++++++++++++++++++++++++++---
 1 file changed, 137 insertions(+), 8 deletions(-)

diff --git a/drivers/clk/meson/g12a.c b/drivers/clk/meson/g12a.c
index 66cf791bfc8c..076e448a3ca3 100644
--- a/drivers/clk/meson/g12a.c
+++ b/drivers/clk/meson/g12a.c
@@ -4992,6 +4992,58 @@ static int meson_g12b_dvfs_setup(struct platform_device *pdev)
 	return 0;
 }
 
+static int meson_g12b_suspend(struct device *dev)
+{
+#if 0
+	/* Setup cpu_clk_premux1 to fclk_div2 */
+	clk_hw_set_parent(&g12a_cpu_clk_premux1.hw,
+			  &g12a_fclk_div2.hw);
+
+	/* Setup cpub_clk_premux1 to fclk_div2 */
+	clk_hw_set_parent(&g12b_cpub_clk_premux1.hw,
+			  &g12a_fclk_div2.hw);
+
+	/* Setup cpu_clk_postmux1 to bypass divider */
+	clk_hw_set_parent(&g12a_cpu_clk_postmux1.hw,
+			  &g12a_cpu_clk_premux1.hw);
+
+	/* Setup cpub_clk_postmux1 to bypass divider */
+	clk_hw_set_parent(&g12b_cpub_clk_postmux1.hw,
+			  &g12b_cpub_clk_premux1.hw);
+
+	/* Switch to parking clk on cpu_clk_postmux1 */
+	clk_hw_set_parent(&g12a_cpu_clk_dyn.hw,
+			  &g12a_cpu_clk_postmux1.hw);
+
+	/* Switch to parking clk on cpub_clk_postmux1 */
+	clk_hw_set_parent(&g12b_cpub_clk_dyn.hw,
+			  &g12b_cpub_clk_postmux1.hw);
+
+	/* Configure cpu_clk to use cpu_clk_dyn */
+	clk_hw_set_parent(&g12b_cpu_clk.hw,
+			  &g12a_cpu_clk_dyn.hw);
+
+	/* Configure cpub_clk to use cpub_clk_dyn */
+	clk_hw_set_parent(&g12b_cpub_clk.hw,
+			  &g12b_cpub_clk_dyn.hw);
+#endif
+
+	return 0;
+}
+
+static int meson_g12b_resume(struct device *dev)
+{
+	u32 ret;
+
+	ret = clk_invalidate_rate(
+			__clk_lookup(clk_hw_get_name(&g12b_cpu_clk.hw)));
+	if (ret)
+		return ret;
+
+	return clk_invalidate_rate(
+			__clk_lookup(clk_hw_get_name(&g12b_cpub_clk.hw)));
+}
+
 static int meson_g12a_dvfs_setup(struct platform_device *pdev)
 {
 	struct clk_hw **hws = g12a_hw_onecell_data.hws;
@@ -5024,34 +5076,100 @@ static int meson_g12a_dvfs_setup(struct platform_device *pdev)
 	return 0;
 }
 
+static int meson_g12a_suspend(struct device *dev)
+{
+#if 0
+	/* Setup cpu_clk_premux1 to fclk_div2 */
+	clk_hw_set_parent(&g12a_cpu_clk_premux1.hw,
+			  &g12a_fclk_div2.hw);
+
+	/* Setup cpu_clk_postmux1 to bypass divider */
+	clk_hw_set_parent(&g12a_cpu_clk_postmux1.hw,
+			  &g12a_cpu_clk_premux1.hw);
+
+	/* Switch to parking clk on cpu_clk_postmux1 */
+	clk_hw_set_parent(&g12b_cpub_clk_dyn.hw,
+			  &g12a_cpu_clk_postmux1.hw);
+
+	/* Configure cpu_clk to use cpu_clk_dyn */
+	clk_hw_set_parent(&g12a_cpu_clk.hw,
+			  &g12a_cpu_clk_dyn.hw);
+#endif
+
+	return 0;
+}
+
+static int meson_g12a_resume(struct device *dev)
+{
+	return clk_invalidate_rate(
+			__clk_lookup(clk_hw_get_name(&g12a_cpu_clk.hw)));
+}
+
 struct meson_g12a_data {
 	const struct meson_eeclkc_data eeclkc_data;
 	int (*dvfs_setup)(struct platform_device *pdev);
+	int (*suspend)(struct device *dev);
+	int (*resume)(struct device *dev);
 };
 
+static const struct
+meson_g12a_data *meson_g12a_get_data(struct device *dev)
+{
+	const struct meson_eeclkc_data *eeclkc_data =
+			of_device_get_match_data(dev);
+
+	if (!eeclkc_data)
+		return ERR_PTR(-EINVAL);
+
+	return container_of(eeclkc_data, struct meson_g12a_data,
+			    eeclkc_data);
+}
+
 static int meson_g12a_probe(struct platform_device *pdev)
 {
-	const struct meson_eeclkc_data *eeclkc_data;
-	const struct meson_g12a_data *g12a_data;
 	int ret;
+	const struct meson_g12a_data *g12a_data =
+			meson_g12a_get_data(&pdev->dev);
 
-	eeclkc_data = of_device_get_match_data(&pdev->dev);
-	if (!eeclkc_data)
-		return -EINVAL;
+	if (IS_ERR(g12a_data))
+		return PTR_ERR(g12a_data);
 
 	ret = meson_eeclkc_probe(pdev);
 	if (ret)
 		return ret;
 
-	g12a_data = container_of(eeclkc_data, struct meson_g12a_data,
-				 eeclkc_data);
-
 	if (g12a_data->dvfs_setup)
 		return g12a_data->dvfs_setup(pdev);
 
 	return 0;
 }
 
+static int __maybe_unused g12a_clkc_suspend(struct device *dev)
+{
+	const struct meson_g12a_data *g12a_data = meson_g12a_get_data(dev);
+
+	if (IS_ERR(g12a_data))
+		return PTR_ERR(g12a_data);
+
+	if (g12a_data->suspend)
+		return g12a_data->suspend(dev);
+
+	return 0;
+}
+
+static int __maybe_unused g12a_clkc_resume(struct device *dev)
+{
+	const struct meson_g12a_data *g12a_data = meson_g12a_get_data(dev);
+
+	if (IS_ERR(g12a_data))
+		return PTR_ERR(g12a_data);
+
+	if (g12a_data->resume)
+		return g12a_data->resume(dev);
+
+	return 0;
+}
+
 static const struct meson_g12a_data g12a_clkc_data = {
 	.eeclkc_data = {
 		.regmap_clks = g12a_clk_regmaps,
@@ -5061,6 +5179,8 @@ static const struct meson_g12a_data g12a_clkc_data = {
 		.init_count = ARRAY_SIZE(g12a_init_regs),
 	},
 	.dvfs_setup = meson_g12a_dvfs_setup,
+	.suspend = meson_g12a_suspend,
+	.resume = meson_g12a_resume,
 };
 
 static const struct meson_g12a_data g12b_clkc_data = {
@@ -5070,6 +5190,8 @@ static const struct meson_g12a_data g12b_clkc_data = {
 		.hw_onecell_data = &g12b_hw_onecell_data,
 	},
 	.dvfs_setup = meson_g12b_dvfs_setup,
+	.suspend = meson_g12b_suspend,
+	.resume = meson_g12b_resume,
 };
 
 static const struct meson_g12a_data sm1_clkc_data = {
@@ -5079,6 +5201,12 @@ static const struct meson_g12a_data sm1_clkc_data = {
 		.hw_onecell_data = &sm1_hw_onecell_data,
 	},
 	.dvfs_setup = meson_g12a_dvfs_setup,
+	.suspend = meson_g12a_suspend,
+	.resume = meson_g12a_resume,
+};
+
+static const struct dev_pm_ops g12a_clkc_dev_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(g12a_clkc_suspend, g12a_clkc_resume)
 };
 
 static const struct of_device_id clkc_match_table[] = {
@@ -5102,6 +5230,7 @@ static struct platform_driver g12a_driver = {
 	.driver		= {
 		.name	= "g12a-clkc",
 		.of_match_table = clkc_match_table,
+		.pm	= &g12a_clkc_dev_pm_ops,
 	},
 };
 
-- 
2.17.1

