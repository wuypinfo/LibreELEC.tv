diff --git a/configure b/configure
index 470ef908ff..b8743891ad 100755
--- a/configure
+++ b/configure
@@ -6498,7 +6498,7 @@ if enabled v4l2_m2m; then
     check_cc mpeg1_v4l2_m2m linux/videodev2.h "int i = V4L2_PIX_FMT_MPEG1;"
     check_cc mpeg2_v4l2_m2m linux/videodev2.h "int i = V4L2_PIX_FMT_MPEG2;"
     check_cc mpeg4_v4l2_m2m linux/videodev2.h "int i = V4L2_PIX_FMT_MPEG4;"
-    check_cc hevc_v4l2_m2m linux/videodev2.h "int i = V4L2_PIX_FMT_HEVC;"
+    check_cc hevc_v4l2_m2m linux/videodev2.h "int i = 1;"
     check_cc h263_v4l2_m2m linux/videodev2.h "int i = V4L2_PIX_FMT_H263;"
     check_cc h264_v4l2_m2m linux/videodev2.h "int i = V4L2_PIX_FMT_H264;"
     check_cc vp8_v4l2_m2m linux/videodev2.h "int i = V4L2_PIX_FMT_VP8;"
diff --git a/libavcodec/v4l2_buffers.c b/libavcodec/v4l2_buffers.c
index f32eb7cddf..aaee6e0ce4 100644
--- a/libavcodec/v4l2_buffers.c
+++ b/libavcodec/v4l2_buffers.c
@@ -41,6 +41,31 @@
 #include "v4l2_buffers.h"
 #include "v4l2_m2m.h"
 
+#if CONFIG_LIBDRM
+typedef struct format_modifier_map {
+	enum AVPixelFormat format;
+	uint64_t modifier;
+} format_modifier_map;
+
+static const format_modifier_map formats_modifier[] = {
+#ifdef DRM_FORMAT_MOD_AMLOGIC_FBC
+    { AV_PIX_FMT_AM08C, DRM_FORMAT_MOD_AMLOGIC_FBC(DRM_FORMAT_MOD_AMLOGIC_FBC_SCATTER |
+                                                   DRM_FORMAT_MOD_AMLOGIC_FBC_MEM_SAVING) },
+    { AV_PIX_FMT_AM10C, DRM_FORMAT_MOD_AMLOGIC_FBC(DRM_FORMAT_MOD_AMLOGIC_FBC_SCATTER) },
+#endif
+};
+
+static uint64_t get_format_modifier(enum AVPixelFormat format) {
+    int i;
+
+    for (i = 0; i < FF_ARRAY_ELEMS(formats_modifier); ++i)
+        if (formats_modifier[i].format == format)
+	    return formats_modifier[i].modifier;
+
+    return DRM_FORMAT_MOD_LINEAR;
+}
+#endif
+
 #define USEC_PER_SEC 1000000
 static AVRational v4l2_timebase = { 1, USEC_PER_SEC };
 
@@ -266,6 +291,12 @@ static uint8_t *v4l2_get_drm_frame(V4L2Buffer *avbuf)
 {
     AVDRMFrameDescriptor *drm_desc = &avbuf->drm_frame;
     AVDRMLayerDescriptor *layer;
+    uint64_t modifier;
+
+    if (avbuf->context->modifier)
+        modifier = avbuf->context->modifier;
+    else
+        modifier = get_format_modifier(avbuf->context->sw_pix_fmt);
 
     /* fill the DRM frame descriptor */
     drm_desc->nb_objects = avbuf->num_planes;
@@ -278,6 +309,7 @@ static uint8_t *v4l2_get_drm_frame(V4L2Buffer *avbuf)
         layer->planes[i].object_index = i;
         layer->planes[i].offset = 0;
         layer->planes[i].pitch = avbuf->plane_info[i].bytesperline;
+        avbuf->drm_frame.objects[i].format_modifier = modifier;
     }
 
     switch (avbuf->context->sw_pix_fmt) {
@@ -323,6 +355,16 @@ static uint8_t *v4l2_get_drm_frame(V4L2Buffer *avbuf)
         layer->planes[2].pitch = avbuf->plane_info[0].bytesperline >> 1;
         break;
 
+    case AV_PIX_FMT_AM08C:
+        layer->format = DRM_FORMAT_YUV420_8BIT;
+	layer->nb_planes = 1;
+        break;
+
+    case AV_PIX_FMT_AM10C:
+        layer->format = DRM_FORMAT_YUV420_10BIT;
+        layer->nb_planes = 1;
+        break;
+
     default:
         drm_desc->nb_layers = 0;
         break;
@@ -335,6 +377,7 @@ static int v4l2_buffer_export_drm(V4L2Buffer* avbuf)
 {
     struct v4l2_exportbuffer expbuf;
     int i, ret;
+    uint64_t modifier = get_format_modifier(avbuf->context->sw_pix_fmt);
 
     for (i = 0; i < avbuf->num_planes; i++) {
         memset(&expbuf, 0, sizeof(expbuf));
@@ -351,12 +394,12 @@ static int v4l2_buffer_export_drm(V4L2Buffer* avbuf)
             /* drm frame */
             avbuf->drm_frame.objects[i].size = avbuf->buf.m.planes[i].length;
             avbuf->drm_frame.objects[i].fd = expbuf.fd;
-            avbuf->drm_frame.objects[i].format_modifier = DRM_FORMAT_MOD_LINEAR;
+            avbuf->drm_frame.objects[i].format_modifier = modifier;
         } else {
             /* drm frame */
             avbuf->drm_frame.objects[0].size = avbuf->buf.length;
             avbuf->drm_frame.objects[0].fd = expbuf.fd;
-            avbuf->drm_frame.objects[0].format_modifier = DRM_FORMAT_MOD_LINEAR;
+            avbuf->drm_frame.objects[0].format_modifier = modifier;
         }
     }
 
@@ -497,6 +540,9 @@ static int v4l2_buffer_swframe_to_buf(const AVFrame *frame, V4L2Buffer *out)
     case V4L2_PIX_FMT_NV12MT:
     case V4L2_PIX_FMT_NV16M:
     case V4L2_PIX_FMT_NV61M:
+#ifdef V4L2_PIX_FMT_AM21C
+    case V4L2_PIX_FMT_AM21C:
+#endif
         is_planar_format = 1;
     }
 
diff --git a/libavcodec/v4l2_context.c b/libavcodec/v4l2_context.c
index 298799f0ad..87aea94231 100644
--- a/libavcodec/v4l2_context.c
+++ b/libavcodec/v4l2_context.c
@@ -30,6 +30,7 @@
 #include "libavcodec/avcodec.h"
 #include "libavcodec/internal.h"
 #include "libavutil/avassert.h"
+#include "libavutil/pixdesc.h"
 #include "v4l2_buffers.h"
 #include "v4l2_fmt.h"
 #include "v4l2_m2m.h"
@@ -204,6 +205,17 @@ static int v4l2_handle_event(V4L2Context *ctx)
         s->capture.width = v4l2_get_width(&cap_fmt);
         s->capture.sample_aspect_ratio = v4l2_get_sar(&s->capture);
     }
+    if (s->avctx->pix_fmt == AV_PIX_FMT_DRM_PRIME) {
+#if defined(VIDIOC_G_EXT_FMT)
+        struct v4l2_ext_format f = { .type = V4L2_BUF_TYPE_VIDEO_CAPTURE };
+        ret = ioctl(s->fd, VIDIOC_G_EXT_FMT, &f);
+        if (!ret)
+            s->capture.modifier = f.fmt.pix.modifier;
+#endif
+        s->capture.sw_pix_fmt =
+            ff_v4l2_format_v4l2_to_avfmt(cap_fmt.fmt.pix_mp.pixelformat, AV_CODEC_ID_RAWVIDEO);
+        s->avctx->sw_pix_fmt = s->capture.sw_pix_fmt;
+    }
 
     if (full_reinit || reinit)
         s->reinit = 1;
diff --git a/libavcodec/v4l2_context.h b/libavcodec/v4l2_context.h
index f4d4289c11..8a5b4f328e 100644
--- a/libavcodec/v4l2_context.h
+++ b/libavcodec/v4l2_context.h
@@ -65,6 +65,11 @@ typedef struct V4L2Context {
      */
     struct v4l2_format format;
 
+    /**
+     * Optional DRM modifiers tied to this formats
+     */
+    uint64_t modifier;
+
     /**
      * Width and height of the frames it produces (in case of a capture context, e.g. when decoding)
      * or accepts (in case of an output context, e.g. when encoding).
diff --git a/libavcodec/v4l2_fmt.c b/libavcodec/v4l2_fmt.c
index 6df47e3f5a..5db6fc799a 100644
--- a/libavcodec/v4l2_fmt.c
+++ b/libavcodec/v4l2_fmt.c
@@ -74,6 +74,12 @@ static const struct fmt_conversion {
 #ifdef V4L2_PIX_FMT_NV16M
     { AV_FMT(NV16),        AV_CODEC(RAWVIDEO),    V4L2_FMT(NV16M) },
 #endif
+#ifdef V4L2_PIX_FMT_AM08C
+    { AV_FMT(AM08C),       AV_CODEC(RAWVIDEO),    V4L2_FMT(AM08C) },
+#endif
+#ifdef V4L2_PIX_FMT_AM10C
+    { AV_FMT(AM10C),       AV_CODEC(RAWVIDEO),    V4L2_FMT(AM10C) },
+#endif
 #ifdef V4L2_PIX_FMT_H263
     { AV_FMT(NONE),        AV_CODEC(H263),        V4L2_FMT(H263) },
 #endif
diff --git a/libavcodec/v4l2_fmt.h b/libavcodec/v4l2_fmt.h
index 01360029c8..f124bd505a 100644
--- a/libavcodec/v4l2_fmt.h
+++ b/libavcodec/v4l2_fmt.h
@@ -27,6 +27,11 @@
 #include "libavcodec/avcodec.h"
 #include "libavutil/pixfmt.h"
 
+/* TODO: fetch from actual kernel/drm headers */
+#define V4L2_PIX_FMT_AM08C    v4l2_fourcc('A', 'M', '0', '8') /* Amlogic compressed block mode  */
+#define V4L2_PIX_FMT_AM10C    v4l2_fourcc('A', 'M', '1', '0') /* Amlogic compressed block mode  */
+#define V4L2_PIX_FMT_HEVC     v4l2_fourcc('H', 'E', 'V', 'C') /* HEVC aka H.265 */
+
 enum AVPixelFormat ff_v4l2_format_v4l2_to_avfmt(uint32_t v4l2_fmt, enum AVCodecID avcodec);
 uint32_t ff_v4l2_format_avcodec_to_v4l2(enum AVCodecID avcodec);
 uint32_t ff_v4l2_format_avfmt_to_v4l2(enum AVPixelFormat avfmt);
diff --git a/libavcodec/v4l2_m2m.h b/libavcodec/v4l2_m2m.h
index 1d3e6e34cf..f7e14984fe 100644
--- a/libavcodec/v4l2_m2m.h
+++ b/libavcodec/v4l2_m2m.h
@@ -32,6 +32,13 @@
 #include "libavcodec/avcodec.h"
 #include "v4l2_context.h"
 
+/* TODO: fetch from actual kernel/drm headers */
+#define DRM_FORMAT_MOD_VENDOR_AMLOGIC 0x0a
+#define DRM_FORMAT_MOD_AMLOGIC_FBC_DEFAULT fourcc_mod_code(AMLOGIC, 0)
+#define DRM_FORMAT_MOD_AMLOGIC_FBC(__modes) fourcc_mod_code(AMLOGIC, __modes)
+#define DRM_FORMAT_MOD_AMLOGIC_FBC_SCATTER	(1ULL << 0)
+#define DRM_FORMAT_MOD_AMLOGIC_FBC_MEM_SAVING	(1ULL << 1)
+
 #define container_of(ptr, type, member) ({ \
         const __typeof__(((type *)0)->member ) *__mptr = (ptr); \
         (type *)((char *)__mptr - offsetof(type,member) );})
diff --git a/libavcodec/v4l2_m2m_dec.c b/libavcodec/v4l2_m2m_dec.c
index 406941cb14..326ccc30ea 100644
--- a/libavcodec/v4l2_m2m_dec.c
+++ b/libavcodec/v4l2_m2m_dec.c
@@ -211,7 +211,7 @@ static av_cold int v4l2_decode_init(AVCodecContext *avctx)
     avctx->pix_fmt = ff_get_format(avctx, avctx->codec->pix_fmts);
     switch (avctx->pix_fmt) {
     case AV_PIX_FMT_DRM_PRIME:
-        avctx->sw_pix_fmt = AV_PIX_FMT_NV12;
+        avctx->sw_pix_fmt = AV_PIX_FMT_AM10C;
         break;
 
     case AV_PIX_FMT_NONE:
diff --git a/libavutil/pixdesc.c b/libavutil/pixdesc.c
index 05dd4a1e20..be9967d18b 100644
--- a/libavutil/pixdesc.c
+++ b/libavutil/pixdesc.c
@@ -2344,6 +2344,12 @@ static const AVPixFmtDescriptor av_pix_fmt_descriptors[AV_PIX_FMT_NB] = {
         },
         .flags = AV_PIX_FMT_FLAG_PLANAR,
     },
+    [AV_PIX_FMT_AM08C] = {
+        .name = "am08c",
+    },
+    [AV_PIX_FMT_AM10C] = {
+        .name = "am10c",
+    },
 };
 #if FF_API_PLUS1_MINUS1
 FF_ENABLE_DEPRECATION_WARNINGS
diff --git a/libavutil/pixfmt.h b/libavutil/pixfmt.h
index 37ecebd501..44e1da3973 100644
--- a/libavutil/pixfmt.h
+++ b/libavutil/pixfmt.h
@@ -348,6 +348,9 @@ enum AVPixelFormat {
     AV_PIX_FMT_NV24,      ///< planar YUV 4:4:4, 24bpp, 1 plane for Y and 1 plane for the UV components, which are interleaved (first byte U and the following byte V)
     AV_PIX_FMT_NV42,      ///< as above, but U and V bytes are swapped
 
+    AV_PIX_FMT_AM08C,     ///< 8-bit Framebuffer compression used on Amlogic SoCs
+    AV_PIX_FMT_AM10C,     ///< 10-bit Framebuffer compression used on Amlogic SoCs
+
     AV_PIX_FMT_NB         ///< number of pixel formats, DO NOT USE THIS if you want to link with shared libav* because the number of formats might differ between versions
 };
 
